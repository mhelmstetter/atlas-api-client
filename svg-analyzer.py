#!/usr/bin/env python3
"""
SVG Chart Analyzer and Fixer

This script analyzes SVG files generated by JFreeChart and identifies/fixes
whitespace and layout issues. It can be used to:
1. Analyze existing SVG files to report dimensions and structure
2. Fix SVG files to maximize chart area usage
3. Generate a test patched version with modified viewBox and scaling
"""

import os
import sys
import glob
import re
import xml.etree.ElementTree as ET
from xml.dom import minidom

# Register the SVG namespace for proper XML parsing
ET.register_namespace('', "http://www.w3.org/2000/svg")
ET.register_namespace('xlink', "http://www.w3.org/1999/xlink")

def analyze_svg(file_path):
    """Analyze the SVG file and report on its structure and dimensions"""
    print(f"\n{'=' * 40}")
    print(f"Analyzing {os.path.basename(file_path)}")
    print(f"{'=' * 40}")
    
    # Parse the SVG file
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
    except Exception as e:
        print(f"Error parsing SVG: {e}")
        return
    
    # Get SVG root attributes
    width = root.get('width')
    height = root.get('height')
    viewBox = root.get('viewBox')
    preserveAspectRatio = root.get('preserveAspectRatio')
    
    print(f"SVG Root Attributes:")
    print(f"  Width: {width}")
    print(f"  Height: {height}")
    print(f"  ViewBox: {viewBox}")
    print(f"  preserveAspectRatio: {preserveAspectRatio}")
    
    # Count and analyze child elements
    g_elements = root.findall('.//{http://www.w3.org/2000/svg}g')
    print(f"\nStructure:")
    print(f"  Total <g> elements: {len(g_elements)}")
    
    # Look for specific structure (depends on JFreeChart's output)
    plot_g = None
    for g in g_elements:
        if g.get('class') == 'plot':
            plot_g = g
            break
    
    if plot_g is not None:
        plot_transform = plot_g.get('transform')
        print(f"  Plot <g> found with transform: {plot_transform}")
        
        # Parse transform values to identify translation
        if plot_transform and 'translate' in plot_transform:
            match = re.search(r'translate\(([^,]+),([^)]+)\)', plot_transform)
            if match:
                x_translate = float(match.group(1))
                y_translate = float(match.group(2))
                print(f"  Plot translate: x={x_translate}, y={y_translate}")
                
                # Calculate how much space is "wasted"
                w = float(width) if width else 0
                h = float(height) if height else 0
                
                # Rough estimate of wasted space (this is simplistic)
                wasted_x = x_translate
                wasted_y = y_translate
                wasted_right = w - (x_translate + w * 0.8)  # Guessing plot is ~80% of width
                wasted_bottom = h - (y_translate + h * 0.8)  # Guessing plot is ~80% of height
                
                print(f"\nEstimated wasted space:")
                print(f"  Left margin: {wasted_x:.1f}px ({(wasted_x/w)*100:.1f}% of width)")
                print(f"  Top margin: {wasted_y:.1f}px ({(wasted_y/h)*100:.1f}% of height)")
                print(f"  Right margin: {wasted_right:.1f}px ({(wasted_right/w)*100:.1f}% of width)")
                print(f"  Bottom margin: {wasted_bottom:.1f}px ({(wasted_bottom/h)*100:.1f}% of height)")
    
    # Look for clip paths that might be limiting the chart area
    clip_paths = root.findall('.//{http://www.w3.org/2000/svg}clipPath')
    if clip_paths:
        print(f"\nClip paths found: {len(clip_paths)}")
        for i, cp in enumerate(clip_paths):
            print(f"  Clip path #{i+1} id: {cp.get('id')}")
            rects = cp.findall('.//{http://www.w3.org/2000/svg}rect')
            for rect in rects:
                print(f"    Rectangle: x={rect.get('x')}, y={rect.get('y')}, width={rect.get('width')}, height={rect.get('height')}")
    
    return root, tree

def fix_svg(file_path, output_path=None):
    """Fix SVG layout issues to maximize chart area"""
    if output_path is None:
        base_name = os.path.splitext(file_path)[0]
        output_path = f"{base_name}_fixed.svg"
    
    # Parse and analyze the SVG
    root, tree = analyze_svg(file_path)
    
    # Set optimized attributes for the root SVG element
    svg_width = float(root.get('width', '300'))
    svg_height = float(root.get('height', '150'))
    
    # Update viewBox to use exact dimensions 
    root.set('viewBox', f"0 0 {svg_width} {svg_height}")
    
    # Set preserveAspectRatio to "none" to ensure it fills the container
    root.set('preserveAspectRatio', 'none')
    
    # Find the main plot group
    plot_groups = root.findall('.//{http://www.w3.org/2000/svg}g[@class="plot"]')
    
    if plot_groups:
        plot_g = plot_groups[0]
        # Remove any translation that's creating margins
        transform = plot_g.get('transform', '')
        
        # Replace any translation with identity transform
        if 'translate' in transform:
            # Option 1: Remove translation (might cause issues with chart visibility)
            # plot_g.set('transform', re.sub(r'translate\([^)]+\)', '', transform).strip())
            
            # Option 2: Adjust translation to a minimal value (safer)
            match = re.search(r'translate\(([^,]+),([^)]+)\)', transform)
            if match:
                x_translate = float(match.group(1))
                y_translate = float(match.group(2))
                
                # Calculate new translations with reduced margins
                new_x = max(0, x_translate * 0.5)  # Reduce left margin by 50%
                new_y = max(5, y_translate * 0.5)  # Reduce top margin but keep some for title
                
                new_transform = re.sub(r'translate\([^)]+\)', f'translate({new_x},{new_y})', transform)
                plot_g.set('transform', new_transform)
    
    # Find clip paths and expand their rectangles
    clip_paths = root.findall('.//{http://www.w3.org/2000/svg}clipPath')
    for cp in clip_paths:
        rects = cp.findall('.//{http://www.w3.org/2000/svg}rect')
        for rect in rects:
            # Get current values
            x = float(rect.get('x', '0'))
            y = float(rect.get('y', '0'))
            width = float(rect.get('width', '0'))
            height = float(rect.get('height', '0'))
            
            # Expand rectangle (careful not to expand too much)
            rect.set('x', str(max(0, x * 0.8)))  # Reduce left boundary
            rect.set('width', str(width * 1.15))  # Expand width by 15%
            rect.set('height', str(height * 1.15))  # Expand height by 15%
    
    # Save the modified SVG
    tree.write(output_path, encoding='utf-8', xml_declaration=True)
    print(f"\nFixed SVG saved to: {output_path}")
    return output_path

def generate_test_svg(file_path):
    """Generate a test SVG with a grid to visualize the real dimensions"""
    base_name = os.path.splitext(file_path)[0]
    output_path = f"{base_name}_test.svg"
    
    # Parse the original SVG
    tree = ET.parse(file_path)
    root = tree.getroot()
    
    # Get width and height
    width = float(root.get('width', '300'))
    height = float(root.get('height', '150'))
    
    # Create a new SVG with same dimensions
    test_svg = ET.Element('svg')
    test_svg.set('xmlns', 'http://www.w3.org/2000/svg')
    test_svg.set('width', str(width))
    test_svg.set('height', str(height))
    test_svg.set('viewBox', f"0 0 {width} {height}")
    test_svg.set('preserveAspectRatio', 'none')
    
    # Add a border to see the full SVG dimensions
    border = ET.SubElement(test_svg, 'rect')
    border.set('x', '0')
    border.set('y', '0')
    border.set('width', str(width))
    border.set('height', str(height))
    border.set('fill', 'none')
    border.set('stroke', 'red')
    border.set('stroke-width', '1')
    
    # Add grid lines
    for x in range(0, int(width) + 1, 50):
        line = ET.SubElement(test_svg, 'line')
        line.set('x1', str(x))
        line.set('y1', '0')
        line.set('x2', str(x))
        line.set('y2', str(height))
        line.set('stroke', 'rgba(255,0,0,0.2)')
        line.set('stroke-width', '1')
        
        # Add text label for x coordinate
        if x % 100 == 0:
            text = ET.SubElement(test_svg, 'text')
            text.set('x', str(x))
            text.set('y', '10')
            text.set('font-size', '8')
            text.set('fill', 'red')
            text.text = str(x)
    
    for y in range(0, int(height) + 1, 50):
        line = ET.SubElement(test_svg, 'line')
        line.set('x1', '0')
        line.set('y1', str(y))
        line.set('x2', str(width))
        line.set('y2', str(y))
        line.set('stroke', 'rgba(255,0,0,0.2)')
        line.set('stroke-width', '1')
        
        # Add text label for y coordinate
        if y % 100 == 0:
            text = ET.SubElement(test_svg, 'text')
            text.set('x', '5')
            text.set('y', str(y + 10))
            text.set('font-size', '8')
            text.set('fill', 'red')
            text.text = str(y)
    
    # Embed the original SVG
    orig_group = ET.SubElement(test_svg, 'g')
    orig_group.set('opacity', '0.8')
    
    # Read original SVG content
    with open(file_path, 'r', encoding='utf-8') as f:
        svg_content = f.read()
    
    # Extract inner content from original SVG (everything between <svg> and </svg>)
    match = re.search(r'<svg[^>]*>(.*)</svg>', svg_content, re.DOTALL)
    if match:
        inner_content = match.group(1)
        
        # Create temporary file with valid XML
        temp_xml = f'<root xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">{inner_content}</root>'
        
        try:
            # Parse the inner content
            temp_root = ET.fromstring(temp_xml)
            
            # Add all children to our test SVG
            for child in temp_root:
                orig_group.append(child)
        except Exception as e:
            print(f"Error extracting original SVG content: {e}")
            # Fall back to simpler approach - just add the original as an image
            image = ET.SubElement(test_svg, 'image')
            image.set('{http://www.w3.org/1999/xlink}href', os.path.basename(file_path))
            image.set('x', '0')
            image.set('y', '0')
            image.set('width', str(width))
            image.set('height', str(height))
    
    # Write to file with proper XML formatting
    tree = ET.ElementTree(test_svg)
    tree.write(output_path, encoding='utf-8', xml_declaration=True)
    print(f"Test overlay SVG created at: {output_path}")
    return output_path

def create_direct_edit_fixed_svg(file_path, output_path=None):
    """Create a fixed SVG using direct string manipulation (more reliable than DOM)"""
    if output_path is None:
        base_name = os.path.splitext(file_path)[0]
        output_path = f"{base_name}_direct_fixed.svg"
    
    with open(file_path, 'r', encoding='utf-8') as f:
        svg_content = f.read()
    
    # Extract width and height
    width_match = re.search(r'width="([^"]+)"', svg_content)
    height_match = re.search(r'height="([^"]+)"', svg_content)
    
    if width_match and height_match:
        width = width_match.group(1)
        height = height_match.group(1)
        
        # Add viewBox attribute if it doesn't exist
        if 'viewBox' not in svg_content:
            svg_content = svg_content.replace('<svg ', f'<svg viewBox="0 0 {width} {height}" ')
        
        # Add preserveAspectRatio attribute
        if 'preserveAspectRatio' not in svg_content:
            svg_content = svg_content.replace('<svg ', '<svg preserveAspectRatio="none" ')
        
        # Find and modify plot group transform
        plot_transform_match = re.search(r'<g class="plot"[^>]*transform="([^"]+)"', svg_content)
        if plot_transform_match:
            transform = plot_transform_match.group(1)
            translate_match = re.search(r'translate\(([^,]+),([^)]+)\)', transform)
            
            if translate_match:
                x_translate = float(translate_match.group(1))
                y_translate = float(translate_match.group(2))
                
                # Reduce margins while keeping small spacing for axes
                new_x = max(20, x_translate * 0.5)  # Reduce but keep some margin
                new_y = max(20, y_translate * 0.5)  # Reduce but keep some margin
                
                new_transform = transform.replace(
                    f'translate({translate_match.group(1)},{translate_match.group(2)})',
                    f'translate({new_x},{new_y})'
                )
                
                svg_content = svg_content.replace(
                    f'<g class="plot" transform="{transform}"',
                    f'<g class="plot" transform="{new_transform}"'
                )
        
        # Find and modify clip paths for plot areas
        rect_pattern = r'<clipPath id="[^"]+"><rect x="([^"]+)" y="([^"]+)" width="([^"]+)" height="([^"]+)"/></clipPath>'
        for match in re.finditer(rect_pattern, svg_content):
            x = float(match.group(1))
            y = float(match.group(2))
            w = float(match.group(3))
            h = float(match.group(4))
            
            # Expand the clip rectangle by 15%
            new_w = w * 1.15
            new_h = h * 1.15
            
            original_rect = match.group(0)
            new_rect = original_rect.replace(
                f'width="{match.group(3)}" height="{match.group(4)}"',
                f'width="{new_w}" height="{new_h}"'
            )
            
            svg_content = svg_content.replace(original_rect, new_rect)
    
    # Write the modified SVG
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(svg_content)
    
    print(f"Direct-edit fixed SVG saved to: {output_path}")
    return output_path

def main():
    """Main function to process command line arguments"""
    if len(sys.argv) < 2:
        print("Usage: python svg_chart_analyzer.py [file.svg] [--all]")
        print("       --all : Process all SVG files in the current directory")
        return
    
    if sys.argv[1] == '--all':
        # Process all SVG files in the current directory
        svg_files = glob.glob("*.svg")
        if not svg_files:
            print("No SVG files found in the current directory.")
            return
        
        for file in svg_files:
            analyze_svg(file)
            fix_svg(file)
            generate_test_svg(file)
            create_direct_edit_fixed_svg(file)
    else:
        file_path = sys.argv[1]
        if not os.path.exists(file_path):
            print(f"File not found: {file_path}")
            return
        
        analyze_svg(file_path)
        
        choice = input("\nWhat would you like to do?\n"
                       "1. Fix SVG layout (DOM method)\n"
                       "2. Fix SVG layout (direct edit method)\n"
                       "3. Generate test overlay\n"
                       "4. All of the above\n"
                       "Choice (1-4): ")
        
        if choice == '1' or choice == '4':
            fix_svg(file_path)
        
        if choice == '2' or choice == '4':
            create_direct_edit_fixed_svg(file_path)
        
        if choice == '3' or choice == '4':
            generate_test_svg(file_path)

if __name__ == "__main__":
    main()
